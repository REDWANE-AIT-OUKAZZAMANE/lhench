{"version":3,"sources":["App.tsx","index.tsx"],"names":["GRID_SIZE","getRandomCoords","newBugPos","snakeBody","arguments","length","undefined","isOverlap","x","Math","floor","random","y","some","segment","App","getInitialSnake","useCallback","snake","setSnake","useState","bug","setBug","direction","setDirection","nextDirection","setNextDirection","score","setScore","isGameOver","setIsGameOver","speed","setSpeed","gameLoopTimeoutRef","useRef","gameContainerRef","resetGame","_gameContainerRef$cur","initialSnake","current","focus","runGameLoop","prevSnake","currentHead","newHead","ateBug","prevScore","prevSpeed","max","newSnake","pop","useEffect","clearTimeout","setTimeout","handleKeyDown","e","newDirection","key","_gameContainerRef$cur2","onKeyDown","window","addEventListener","removeEventListener","_jsxs","className","children","_jsx","round","ref","tabIndex","style","perspective","map","index","left","top","width","height","transform","transition","onClick","rootElement","document","getElementById","Error","createRoot","render","StrictMode"],"mappings":"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","file":"static/js/main.b4ac8b22.chunk.js","sourcesContent":["import React, { useState, useEffect, useCallback, useRef } from 'react';\r\n\r\n// --- Constants ---\r\nconst GRID_SIZE = 20; // The grid will be 20x20 cells\r\nconst CONTAINER_WIDTH_CLASS = 'w-80'; // Approx GRID_SIZE * 1rem (w-4) = 20rem\r\nconst CONTAINER_HEIGHT_CLASS = 'h-80'; // Approx GRID_SIZE * 1rem (h-4) = 20rem\r\nconst INITIAL_SPEED = 200; // Milliseconds between game ticks\r\nconst SPEED_INCREMENT = 5; // Speed increase per bug eaten (ms reduction)\r\nconst MIN_SPEED = 60; // Fastest speed allowed\r\n\r\n// --- Types ---\r\ntype Coordinate = {\r\n  x: number;\r\n  y: number;\r\n};\r\n\r\ntype Direction = 'UP' | 'DOWN' | 'LEFT' | 'RIGHT';\r\n\r\n// --- Helper Functions ---\r\nconst getRandomCoords = (snakeBody: Coordinate[] = []): Coordinate => {\r\n  let newBugPos: Coordinate;\r\n  let isOverlap = false;\r\n  do {\r\n    newBugPos = {\r\n      x: Math.floor(Math.random() * GRID_SIZE),\r\n      y: Math.floor(Math.random() * GRID_SIZE),\r\n    };\r\n    // Check if the new position overlaps with any part of the snake\r\n    isOverlap = snakeBody.some(segment => segment.x === newBugPos.x && segment.y === newBugPos.y);\r\n  } while (isOverlap); // Keep trying until a non-overlapping position is found\r\n  return newBugPos;\r\n};\r\n\r\n// --- React Component ---\r\nconst App: React.FC = () => {\r\n  // --- State ---\r\n  const getInitialSnake = useCallback((): Coordinate[] => [{\r\n    x: Math.floor(GRID_SIZE / 2),\r\n    y: Math.floor(GRID_SIZE / 2)\r\n  }], []);\r\n\r\n  const [snake, setSnake] = useState<Coordinate[]>(getInitialSnake);\r\n  const [bug, setBug] = useState<Coordinate>(getRandomCoords(getInitialSnake()));\r\n  const [direction, setDirection] = useState<Direction>('RIGHT');\r\n  const [nextDirection, setNextDirection] = useState<Direction>('RIGHT'); // Input buffer\r\n  const [score, setScore] = useState<number>(0);\r\n  const [isGameOver, setIsGameOver] = useState<boolean>(false);\r\n  const [speed, setSpeed] = useState<number>(INITIAL_SPEED);\r\n\r\n  // --- Refs ---\r\n  const gameLoopTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n  const gameContainerRef = useRef<HTMLDivElement>(null); // Ref for focusing the game area\r\n\r\n  // --- Game Logic Functions ---\r\n  // Reset the game to its initial state\r\n  const resetGame = useCallback(() => {\r\n    const initialSnake = getInitialSnake();\r\n    setSnake(initialSnake);\r\n    setBug(getRandomCoords(initialSnake));\r\n    setDirection('RIGHT');\r\n    setNextDirection('RIGHT');\r\n    setScore(0);\r\n    setIsGameOver(false);\r\n    setSpeed(INITIAL_SPEED);\r\n    // Ensure the game container has focus to capture keyboard events\r\n    gameContainerRef.current?.focus();\r\n  }, [getInitialSnake]);\r\n\r\n  // Main game loop logic\r\n  const runGameLoop = useCallback(() => {\r\n    if (isGameOver) return;\r\n\r\n    // Update direction from the buffered input\r\n    setDirection(nextDirection);\r\n\r\n    setSnake(prevSnake => {\r\n      const currentHead = prevSnake[0];\r\n      let newHead: Coordinate;\r\n\r\n      // Calculate new head position based on the direction\r\n      switch (nextDirection) {\r\n        case 'UP':\r\n          newHead = { x: currentHead.x, y: currentHead.y - 1 };\r\n          break;\r\n        case 'DOWN':\r\n          newHead = { x: currentHead.x, y: currentHead.y + 1 };\r\n          break;\r\n        case 'LEFT':\r\n          newHead = { x: currentHead.x - 1, y: currentHead.y };\r\n          break;\r\n        case 'RIGHT':\r\n          newHead = { x: currentHead.x + 1, y: currentHead.y };\r\n          break;\r\n        default:\r\n          newHead = currentHead;\r\n      }\r\n\r\n      // Border collision detection\r\n      if (\r\n        newHead.x < 0 ||\r\n        newHead.x >= GRID_SIZE ||\r\n        newHead.y < 0 ||\r\n        newHead.y >= GRID_SIZE\r\n      ) {\r\n        setIsGameOver(true);\r\n        return prevSnake; // Stop update, game over\r\n      }\r\n\r\n      // Self collision detection\r\n      if (prevSnake.some(segment => segment.x === newHead.x && segment.y === newHead.y)) {\r\n        setIsGameOver(true);\r\n        return prevSnake; // Stop update, game over\r\n      }\r\n\r\n      // Bug eating logic\r\n      let ateBug = false;\r\n      if (newHead.x === bug.x && newHead.y === bug.y) {\r\n        ateBug = true;\r\n        setScore(prevScore => prevScore + 1);\r\n        // Increase speed, but not below MIN_SPEED\r\n        setSpeed(prevSpeed => Math.max(MIN_SPEED, prevSpeed - SPEED_INCREMENT));\r\n      }\r\n\r\n      // Update snake\r\n      const newSnake = [newHead, ...prevSnake]; // Add new head\r\n      if (!ateBug) {\r\n        newSnake.pop(); // Remove tail if no bug was eaten\r\n      }\r\n\r\n      // Generate new bug if eaten\r\n      if (ateBug) {\r\n        setBug(getRandomCoords(newSnake));\r\n      }\r\n\r\n      return newSnake;\r\n    });\r\n  }, [bug, nextDirection, isGameOver]);\r\n\r\n  // --- Effects ---\r\n  // Game loop timer effect\r\n  useEffect(() => {\r\n    if (isGameOver) {\r\n      if (gameLoopTimeoutRef.current) {\r\n        clearTimeout(gameLoopTimeoutRef.current);\r\n      }\r\n      return;\r\n    }\r\n\r\n    // Clear existing timeout\r\n    if (gameLoopTimeoutRef.current) {\r\n      clearTimeout(gameLoopTimeoutRef.current);\r\n    }\r\n\r\n    // Set new timeout\r\n    gameLoopTimeoutRef.current = setTimeout(runGameLoop, speed);\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      if (gameLoopTimeoutRef.current) {\r\n        clearTimeout(gameLoopTimeoutRef.current);\r\n      }\r\n    };\r\n  }, [runGameLoop, speed, isGameOver, snake]);\r\n\r\n  // Keyboard input effect\r\n  const handleKeyDown = useCallback((e: KeyboardEvent) => {\r\n    if (isGameOver) return;\r\n\r\n    let newDirection: Direction | null = null;\r\n    switch (e.key) {\r\n      case 'ArrowUp':\r\n        if (direction !== 'DOWN') newDirection = 'UP';\r\n        break;\r\n      case 'ArrowDown':\r\n        if (direction !== 'UP') newDirection = 'DOWN';\r\n        break;\r\n      case 'ArrowLeft':\r\n        if (direction !== 'RIGHT') newDirection = 'LEFT';\r\n        break;\r\n      case 'ArrowRight':\r\n        if (direction !== 'LEFT') newDirection = 'RIGHT';\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n\r\n    if (newDirection) {\r\n      setNextDirection(newDirection);\r\n    }\r\n  }, [direction, isGameOver]);\r\n\r\n  // Keyboard event listener effect\r\n  useEffect(() => {\r\n    // Focus the container on mount\r\n    gameContainerRef.current?.focus();\r\n\r\n    // Event handler\r\n    const onKeyDown = (e: KeyboardEvent) => {\r\n      handleKeyDown(e);\r\n    };\r\n    \r\n    // Add event listener\r\n    window.addEventListener('keydown', onKeyDown);\r\n\r\n    // Cleanup on unmount\r\n    return () => {\r\n      window.removeEventListener('keydown', onKeyDown);\r\n    };\r\n  }, [handleKeyDown]);\r\n\r\n  // --- Rendering ---\r\n  return (\r\n    <div className=\"flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white p-4 font-sans\">\r\n      <h1 className=\"text-3xl font-bold mb-4 text-green-400\">Snake Game</h1>\r\n      \r\n      <div className=\"flex items-center justify-between w-full max-w-md mb-4 px-2\">\r\n        <div className=\"text-xl font-medium\">Score: <span className=\"text-yellow-400 font-bold\">{score}</span></div>\r\n        <div className=\"text-sm text-gray-400\">Speed: {Math.round(1000 / speed)} blocks/sec</div>\r\n      </div>\r\n\r\n      {/* Game Container */}\r\n      <div\r\n        ref={gameContainerRef}\r\n        tabIndex={0}\r\n        className={`relative ${CONTAINER_WIDTH_CLASS} ${CONTAINER_HEIGHT_CLASS} bg-gray-800 border-4 border-green-700 rounded-lg overflow-hidden shadow-2xl focus:outline-none focus:ring-4 focus:ring-green-500/50`}\r\n        style={{ perspective: '800px' }}\r\n      >\r\n        {/* Snake Segments */}\r\n        {snake.map((segment, index) => (\r\n          <div\r\n            key={index}\r\n            className={`absolute rounded ${index === 0 ? 'bg-green-400 z-10' : 'bg-green-600'} shadow-md border border-green-700/50`}\r\n            style={{\r\n              left: `${segment.x * (100 / GRID_SIZE)}%`,\r\n              top: `${segment.y * (100 / GRID_SIZE)}%`,\r\n              width: `${100 / GRID_SIZE}%`,\r\n              height: `${100 / GRID_SIZE}%`,\r\n              transform: `translateZ(${index === 0 ? '5px' : '0px'}) scale(${index === 0 ? 1.1 : 1.0})`,\r\n              transition: 'left 0.1s linear, top 0.1s linear, transform 0.1s ease-out',\r\n            }}\r\n          />\r\n        ))}\r\n\r\n        {/* Bug */}\r\n        <div\r\n          className=\"absolute bg-red-500 rounded-full shadow-xl animate-pulse border border-red-700/50\"\r\n          style={{\r\n            left: `${bug.x * (100 / GRID_SIZE)}%`,\r\n            top: `${bug.y * (100 / GRID_SIZE)}%`,\r\n            width: `${100 / GRID_SIZE}%`,\r\n            height: `${100 / GRID_SIZE}%`,\r\n            transform: 'translateZ(3px) scale(0.9)',\r\n          }}\r\n        />\r\n\r\n        {/* Game Over Overlay */}\r\n        {isGameOver && (\r\n          <div className=\"absolute inset-0 bg-black/80 flex flex-col items-center justify-center text-center z-20 rounded-md\">\r\n            <h2 className=\"text-5xl font-extrabold text-red-500 mb-4 drop-shadow-lg\">Game Over!</h2>\r\n            <p className=\"text-2xl mb-8 text-gray-200\">Your Final Score: <span className=\"text-yellow-400 font-bold\">{score}</span></p>\r\n            <button\r\n              onClick={resetGame}\r\n              className=\"px-8 py-3 bg-blue-600 hover:bg-blue-700 text-white text-lg font-semibold rounded-lg shadow-lg transition-all duration-200 ease-in-out transform hover:scale-105 focus:outline-none focus:ring-4 focus:ring-blue-400/50\"\r\n            >\r\n              Restart Game\r\n            </button>\r\n          </div>\r\n        )}\r\n      </div>\r\n      \r\n      <p className=\"mt-6 text-sm text-gray-400\">Use <kbd className=\"px-1 py-0.5 border border-gray-500 rounded bg-gray-700 text-gray-300\">Arrow Keys</kbd> to control the snake.</p>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default App;\r\n","import React, { StrictMode } from \"react\";\nimport { createRoot } from \"react-dom/client\";\nimport \"./styles.css\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\n\nif (!rootElement) {\n  throw new Error(\"Failed to find the root element\");\n}\n\nconst root = createRoot(rootElement);\nroot.render(\n  <StrictMode>\n    <App />\n  </StrictMode>\n);"],"sourceRoot":""}